# Упражнение №10 - Рекурсия

## [Рекурсия](https://en.wikipedia.org/wiki/Recursion):

1. **Идея**: целта е да сведем решението на дадена задача до комбинация от по-прости случаи на _същата_, или _[подобна](https://en.wikipedia.org/wiki/Mutual_recursion)_, задача.

3. **Структура**: _всяка_ рекурсивна функия се състой от:
   - Едно или повече **_"дъна"_** (гранични/базови случаи): това за най-простите случаи, чието решение ни е известно _от само себе си_
      - Когато работим с числа, това обикновено са стойностите `0` и `1`
      - Когато работим с масиви: празният масив или този с един елемент
   - Общ случай: целта тук е да се приближим към някое от дъната (напр. `n` -> `n - 1`)

3. Паралели между _рекурсия_ и _математическa индукция_: подобно на рекурсията, в математическата индукция доказваме едно твърдение като
   - Един, или няколко, базови случая: това са точно дъната на рекурсията!
   - Индуктивна стъпка: приемайки, че твърдението е вярно `n-1`, доказваме, че то е вярно и за `n`.

4. Еквивалентност между рекурсия и итерация (for/while): _**Всеки**_ итеративен алгоритъм може да бъде реформулиран като рекурсивен. _**Всеки**_ рекурсивен алгоритъм може да се пренапише итеративно (евентуално с помощта на допълнителни структури от данни). На едно по-дълбоко ниво, двете представляват два различни _**подхода**_ към решаването на един и същ алгоритмичен проблем. Хубаво е да можете да превключвате от единия към другия и обратно.


### Примери

1. **n!**
```cpp
int factorial(int n) {
   if (n <= 1) {
      return 1;
   } else {
      return n * factorial(n - 1);
   }
}
```

2. Сбор на елемените на масив:
```cpp
int sum(int arr[], size_t n) {
   if (n == 0) {
      return 0;
   } else {
      return sum(arr, n - 1) + arr[n-1];
   }
}
```


### [Опашкова рекурсия](https://www.geeksforgeeks.org/tail-recursion/):

Опашковата рекурсия (_tail recursion_) е специален вид рекурсия, където рекурсивното извикване е последното нещо, което се изпълнява във функцията. Това позволява на компилатора да "преизползва" текущата стекова рамка за следващото извикване на функцията, вместо да алокира нова. Това може значително да намали употребата на памет и да предотврати грешки свързани с препълване на стека (_stack overflow_), особено при дълбоки или неограничени рекурсивни процеси.

> :warning: **N.B.** Опашковата рекурсия е неразличима на практика от итерацията като производителност (_performance_) и консумация на памет (_memory footprint_). Съвременните компилатори буквално генерират същия машинен код за двете!

### Примери

1. **n!**
```cpp
int factorial_helper(int n, int res) {
   if (n <= 1) {
      return res;
   } else {
      return factorial_helper(n - 1, n * res);
   }
}

int factorial_tailrec(int n) {
   return factorial_helper(n, 1);
}
```

2. Сбор на елемените на масив:
```cpp
int sum_helper(int arr[], size_t len, int acc) {
   if (len == 0) {
      return acc;
   } else {
      return sum_helper(&arr[1], len - 1, acc + arr[0]);
   }
}

int sum_tailrec(int arr[], size_t len) {
   return sum_helper(arr, len, 0);
}
```

## Задачи:

**Задача 1.** Редица на фибоначи: да се напише **рекурсивна** функция, която приема цяло число `n` и връща `n`-тия член на редицата на фибоначи.

**Задача 2.** Дефинирайте **рекурсивна** функция, която приема числов масив и намира най-голямото и най-малкото от тях.

**Задача 3.** Дефинирайте **рекурсивна** функция, която приема масив от реални числа връща средното им аритметично.

**Задача 4.** Дефинирайте **рекурсивна** функция, която приема символен низ и премахва от него всички символи, които не са малка или главна латинска буква.

**Задача 5.** Провекра за просто число: дефинирайте **рекурсивна** функция `isPrime`, която приема цяло число `n` и връща дали то е просто.

**Задача 6.** `atoi`: дефинирайте **рекурсивна** функция, която приема символен низ и връща числото записано в низа. Ако низът не е валидно цяло число, нека функцията да хвърля подходяща грешка.

**Задача 7.&ast;** **Изход от Лабиринт**: Дефинирайте функция, която приема лабиринт кодиран като двуизмерен масив с размери _NxN_ (N <= 1024) и начални координати и намира изход от лабиринта започващ от тези координати. Можете да приемете, че първоначално проходимите клетки са обозначени с $0$, докато непроходимите с $-1$. Функцията трябва да хвърля грешка, ако първоначалните координати са невалидни или ако не съществува изход започващ от тях.

**Задача 8.&ast;** **[Knapsack](https://en.wikipedia.org/wiki/Knapsack_problem)**: нека имаме множество предмети представено като  списък от цели положителни числа, съдържащ теглото на всеки от предметите, както и _раница_, която може да побере максимално тегло `maxWeight`. Отпечатайте предметите, които трябва да сложим в раницата, за да я запълним максимално без същевременно да превишим максималното ѝ тегло.

**Задача 9.&ast;** Дефинирайте функция, която приема цяло положително число `n` и отпечатва всички пермутации на числата от 1 до `n`.

> :warning: Важно: Броят на пермутациите е $n!$. Тествайте функцията с `n <= 5`!

**Задача 10.&ast;** **[Sudoku](https://en.wikipedia.org/wiki/Sudoku)**: Напишете функция, която приема символен низ (с дължина 81), съответстващ на частично решение на играта судоку и го решава. Функцията да хвърля грешка, ако даденият пъзел не може да бъде решен.

Пример:
- in:  "4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......"
- out: "417369825632158947958724316825437169791586432346912758289643571573291684164875293"

Допълнителни примери можете да намерите [тук](https://norvig.com/top95.txt), а решенията им [тук](https://norvig.com/top95solutions.html)

# Упражнение №8 - Динамична памет


## [Динамични памет](https://cplusplus.com/doc/tutorial/dynamic/)

### _"Скаларни"_ Промеливи: `[const] <тип> *<име> = new <тип>(<инициализатор>);`

```cpp
const int *i  = new int;
const double * const PI = new double(3.14);

// Cleanup:
delete i;
delete PI;
```

### Едномерни масиви: `[const] <тип> *<име> = new <тип>[<брой елементи>];`

```cpp
size_t size;
std::cin >> size;

int *dynamicArray = new int[size];
for (size_t i = 0; i < size; i ++) {
    std::cin >> dynamicArray[i];
}

// Cleanup:
delete[] dynamicArray;
```

### Многомерни масиви: `[const] <тип> (*<име>)[SIZE] = new <тип>[<брой елементи>][SIZE];`

:warning: **Важно!** `SIZE` трябва да е компилационна константа!

```cpp
size_t size;
std::cin >> size;

double (*points3D)[3] = new double[size][3];
for (size_t i = 0; i < size; i ++) {
    std::cout << "Enter x, y, z coordinates: ";
    std::cin >> points3D[i][0] >> points3D[i][1] >> points3D[i][2];
}

// Cleanup:
delete[] points3D;
```

### Масиви от указатели: `[const] <тип> **<име> = new <тип>*[<брой елементи>];`

:warning: **Важно!** Не забравяйте да `delete[]`-нете под-масивите!

```cpp
size_t m, n;
std::cin >> m >> n;

int **matrix = new int*[m];
for (size_t i = 0; i < m; i ++) {
    matrix[i] = new int[n];
    // ...
}

// Cleanup:
for (size_t i = 0; i < m; i ++) {
    delete[] matrix[i];
}
delete[] matrix;
```


## Задачи

> :warning: **ВАЖНО!** Не забравяйте да освободите всички динамични променливи, преди да излезете от `main`!

#### На лист (~20 мин)

**Задача 1.** Дефинирайте функция `isMagicSquare`, която приема квадратна матрица с максимален размер `MAX_SIZE` и връща дали матрицата е магически квадрат. Наричаме една матрица магически квадрат ако сумата на числата във всяка редица, колона и двата главни диагонала е бъде една и съща.

#### На компютър

**Задача 2.** Напишете програма, която да позволява на потребителя да въведе цяло положително число `n`, последвано от `n` на брой точки в равнината, след което да отпечатва координатите и разстоянието между двете най-близки точки.

**Задача 3.** Напишете програма, която да позволява на потребителя да въведе цяло положително число `n`, последвано от `n` на брой цели числа, след което ги отпечатва подредени от най-голямото към най-малкото.

_Бонус_: Променете програмата, така че да не отпечатва повтарящите се числа повече от веднъж.

**Задача 4.** Дефинирайте функция `intersection`, която приема два числени  масива и връща тяхното _сечение_, т.е. множеството от числата (без повторения), които се срещат в и двата масива.

**Задача 5.** Дефинирайте функция `union`, която приема два числени  масива и връща тяхното _обединение_, т.е. множеството от числата (без повторения), които се срещат поне в един от двата масива.

**Задача 6.&ast;** Напишете програма, която прочита цяло положително число `n` и отпечатва първите `n` члена на редицата ["погледни и кажи"](https://en.wikipedia.org/wiki/Look-and-say_sequence). Редицата "погледни и кажи" започва от числото `1` и всяко следващо число се определя от описанието на предходното: `1` (една единица) $\Rightarrow$ `11` (две единици) $\Rightarrow$ `21` (една двойка и една единица) $\Rightarrow$ `1211` , и т.н.
